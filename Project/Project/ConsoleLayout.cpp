#include "pch.h"
#include "ConsoleLayout.h"

// ===========================================================
//                        WriteManager
// ===========================================================

shared_ptr<WriteManager> WriteManager::Instance = nullptr;

void WriteManager::MoveCursor(short x, short y)
{
    // 콘솔 출력 핸들을 가져옵니다.
    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
    if (hConsole == INVALID_HANDLE_VALUE) {
        std::cerr << "Error: Unable to get console handle.\n";
        return;
    }

    // 커서 위치 설정
    COORD coord = { x, y };  // x: 가로, y: 세로 위치
    if (!SetConsoleCursorPosition(hConsole, coord)) {
        std::cerr << "Error: Unable to set cursor position.\n";
    }
}

void WriteManager::MakeLayout(LAYOUT_TYPE LayoutType, int Left, int Top, int Height, int Width)
{
    FConsoleLayout ConsoleLayout(Left, Top, Height, Width);

    ConsoleLayoutContainer.MakeLayout(LayoutType, ConsoleLayout);
}

void WriteManager::MakeAllLayout()
{
    // Title Layout
    MakeLayout(LAYOUT_TYPE::TITLE, 0, 0, 1, 100);

    // Stat Layout
    MakeLayout(LAYOUT_TYPE::STAT, 0, 2, 6, 25);

    // Map Layout
    MakeLayout(LAYOUT_TYPE::MAP, 110, 2, 6, 7);

    // Story Layout
    MakeLayout(LAYOUT_TYPE::STORY, 0, 10, 10, 60);

    // Select Layout
    MakeLayout(LAYOUT_TYPE::SELECT, 0, 22, 5, 60);
}

void WriteManager::ClearLayout(LAYOUT_TYPE TargetLayout)
{
    ConsoleLayoutContainer.clear(TargetLayout);
}

void WriteManager::AddLine(FMessageParam MessageParam)
{
    ConsoleLayoutContainer.AddLine(MessageParam);
}

void WriteManager::render()
{
    ConsoleLayoutContainer.render();
}

void WriteManager::Initialize()
{
    // ConsoleHandle = GetStdHandle(STD_OUTPUT_HANDLE);
    ConsoleLayoutContainer.Initialize();
    MakeAllLayout();
}

void WriteManager::ClearScreen()
{
    ConsoleLayoutContainer.ClearScreen();
}

void WriteManager::SwapBuffer()
{
    ConsoleLayoutContainer.SwapBuffer();
}





// ===========================================================
//                 FConsoleLayoutContainer
// ===========================================================

void FConsoleLayoutContainer::MoveCursor(short x, short y)
{
    // 콘솔 출력 핸들을 가져옵니다.
    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
    if (hConsole == INVALID_HANDLE_VALUE) {
        std::cerr << "Error: Unable to get console handle.\n";
        return;
    }

    // 커서 위치 설정
    COORD coord = { x, y };  // x: 가로, y: 세로 위치
    /*if (!SetConsoleCursorPosition(hConsole, coord)) {
        std::cerr << "Error: Unable to set cursor position.\n";
    }*/
    if (!SetConsoleCursorPosition(Console.HBuffer[Console.CurBufferIndex], coord)) {
        std::cerr << "Error: Unable to set cursor position.\n";
    }
}

void FConsoleLayoutContainer::SetConsoleColor(WORD color)
{
    //SetConsoleTextAttribute(ConsoleHandle, color);
    SetConsoleTextAttribute(Console.HBuffer[Console.CurBufferIndex], color);
}

string FConsoleLayoutContainer::OverwriteTitle(const string& Title)
{
    CONSOLE_SCREEN_BUFFER_INFO ConsoleInfo;
    int LineCount = 0;
    // 콘솔 정보 가져오기
    if (GetConsoleScreenBufferInfo(ConsoleHandle, &ConsoleInfo)) {
        // 콘솔 창의 가로 크기 계산
        LineCount = ConsoleInfo.srWindow.Right - ConsoleInfo.srWindow.Left + 1;
    }

    LineCount -= Title.length();
    string Line;
    for (int i = 0; i < LineCount / 2; ++i)
    {
        Line += "=";
    }

    string output = Line;
    output += Title;
    output += Line;

    if (0 != LineCount % 2)
    {
        output += "=";
    }

    return output;
}

void FConsoleLayoutContainer::MakeLayoutBox(LAYOUT_TYPE LayoutType, FConsoleLayout& ConsoleLayout)
{
    SetConsoleColor((WORD) TEXT_COLOR_TYPE::GRAY | (WORD)BACKGROUND_COLOR_TYPE::BLACK);

    // ┌──────┐
    // │            │
    // │            │
    // └──────┘
    
    // LeftTop
    MoveCursor(ConsoleLayout.Left, ConsoleLayout.Top - 1);
    PrintMessage(L"┌");

    // RightTop
    MoveCursor(ConsoleLayout.Left + ConsoleLayout.Width, ConsoleLayout.Top - 1);
    PrintMessage(L"┐");

    // LeftBot
    MoveCursor(ConsoleLayout.Left, ConsoleLayout.Top + ConsoleLayout.Height);
    PrintMessage(L"└");

    // RightBot
    MoveCursor(ConsoleLayout.Left + ConsoleLayout.Width, ConsoleLayout.Top + ConsoleLayout.Height);
    PrintMessage(L"┘");

    // Up Line
    MoveCursor(ConsoleLayout.Left + 1, ConsoleLayout.Top - 1);
    
    wstring message(ConsoleLayout.Width - 1,L'─');
    PrintMessage(message);
    
    // Down Line
    MoveCursor(ConsoleLayout.Left + 1, ConsoleLayout.Top + ConsoleLayout.Height);
    PrintMessage(message);
    
    
    for (int i = 0; i < ConsoleLayout.Height; ++i)
    {
        // Left Line
        MoveCursor(ConsoleLayout.Left, ConsoleLayout.Top + i);
        std::wstring message = L"│";
        PrintMessage(message);
    
        MoveCursor(ConsoleLayout.Left + ConsoleLayout.Width, ConsoleLayout.Top + i);
        PrintMessage(message);
    }
}

void FConsoleLayoutContainer::PrintMessage(string message)
{
    DWORD written;

    WriteConsole(
        Console.HBuffer[Console.CurBufferIndex], // 현재 활성화된 버퍼 핸들
        message.c_str(),                        // 출력할 데이터
        static_cast<DWORD>(message.size()),     // 데이터 크기
        &written,                               // 실제로 출력된 크기
        NULL                                    // 비동기 처리 옵션 (동기식 처리)
    );
}

void FConsoleLayoutContainer::PrintMessage(wstring message)
{
    DWORD written;

    WriteConsoleW(
        Console.HBuffer[Console.CurBufferIndex], // 현재 활성화된 버퍼 핸들
        message.c_str(),                        // 출력할 데이터
        static_cast<DWORD>(message.size()),     // 데이터 크기
        &written,                               // 실제로 출력된 크기
        NULL                                    // 비동기 처리 옵션 (동기식 처리)
    );
}

FConsoleLayoutContainer::~FConsoleLayoutContainer()
{
    if (nullptr != Console.HBuffer[0])
    {
        CloseHandle(Console.HBuffer[0]);
    }

    if (nullptr != Console.HBuffer[1])
    {
        CloseHandle(Console.HBuffer[1]);
    }
}

void FConsoleLayoutContainer::MakeLayout(LAYOUT_TYPE LayoutType, FConsoleLayout Layout)
{
    if (LayoutMap.find(LayoutType) == LayoutMap.end())
    {
        LayoutMap.insert({ LayoutType, Layout });
    }
}

void FConsoleLayoutContainer::clear(LAYOUT_TYPE TargetType)
{
    const FConsoleLayout& ConsoleLayout = LayoutMap.find(TargetType)->second;

    HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
    if (Console.HBuffer[Console.CurBufferIndex] == INVALID_HANDLE_VALUE) {
        std::cerr << "Error: Unable to get console handle.\n";
        return;
    }

    // 콘솔 정보 가져오기
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    if (!GetConsoleScreenBufferInfo(hConsole, &csbi)) {
        std::cerr << "Error: Unable to get console buffer info.\n";
        return;
    }

    // 시작 위치 계산
    COORD startCoord = { static_cast<SHORT>(ConsoleLayout.Left), static_cast<SHORT>(ConsoleLayout.Top) };
    DWORD cellsToClear = ConsoleLayout.Width * ConsoleLayout.Height; // 지울 셀 개수
    DWORD cellsCleared;

    // 버퍼의 문자 지우기 (공백으로 채우기)
    if (!FillConsoleOutputCharacter(hConsole, ' ', cellsToClear, startCoord, &cellsCleared)) {
        std::cerr << "Error: Unable to clear console buffer.\n";
        return;
    }

    // 버퍼의 속성 초기화 (색상 초기화)
    //if (!FillConsoleOutputAttribute(hConsole, csbi.wAttributes, cellsToClear, startCoord, &cellsCleared)) {
    //    std::cerr << "Error: Unable to reset console attributes.\n";
    //    return;
    //}

    // 커서를 원래 위치로 이동
}

void FConsoleLayoutContainer::AddLine(FMessageParam MessageParam)
{
    if (LayoutMap.find(MessageParam.TargetLayout) != LayoutMap.end())
    {
        if (MessageParam.TargetLayout == LAYOUT_TYPE::TITLE)
        {
            LayoutMap.find(MessageParam.TargetLayout)->second.Message[MessageParam.LineIndex].Message = OverwriteTitle(MessageParam.Message);
        }
        else
        {
            LayoutMap.find(MessageParam.TargetLayout)->second.Message[MessageParam.LineIndex].Message = MessageParam.Message;
        }
        LayoutMap.find(MessageParam.TargetLayout)->second.Message[MessageParam.LineIndex].TextColor = MessageParam.TextColor;
        LayoutMap.find(MessageParam.TargetLayout)->second.Message[MessageParam.LineIndex].BackGroundColor = MessageParam.BackGroundColor;
    }
}

void FConsoleLayoutContainer::render()
{   
    ClearScreen();
    string a;
    cout << "입력";
    fflush(stdin);
    //cin.ignore();
    cin.clear();
    cin >> a;

    map<LAYOUT_TYPE, FConsoleLayout>::iterator iter = LayoutMap.begin();
   
    for (; iter != LayoutMap.end(); ++iter)
    {
        if (iter->first != LAYOUT_TYPE::TITLE)
        {
            // 레이아웃 박스 그리기
            MakeLayoutBox(iter->first, iter->second);
        }

        for (int i = 0; i < iter->second.Message.size(); ++i)
        {
            if(iter->first == LAYOUT_TYPE::TITLE)
                MoveCursor(iter->second.Left, iter->second.Top + i);
            else
                MoveCursor(iter->second.Left + 1, iter->second.Top + i);

            // 색 설정
            SetConsoleColor((WORD)iter->second.Message[i].TextColor | (WORD)iter->second.Message[i].BackGroundColor);

            // 현재 활성화된 버퍼에 출력
            DWORD written;
            std::string message = iter->second.Message[i].Message;

            WriteFile(
                Console.HBuffer[Console.CurBufferIndex], // 현재 활성화된 버퍼 핸들
                message.c_str(),                        // 출력할 데이터
                static_cast<DWORD>(message.size()),     // 데이터 크기
                &written,                               // 실제로 출력된 크기
                NULL                                    // 비동기 처리 옵션 (동기식 처리)
            );
        }
    }

    SwapBuffer();
}

void FConsoleLayoutContainer::Initialize()
{
    ConsoleHandle = GetStdHandle(STD_OUTPUT_HANDLE);

    Console.HConsole = GetStdHandle(STD_OUTPUT_HANDLE);
    Console.CurBufferIndex = 0;
    CONSOLE_CURSOR_INFO ConsoleCursorInfo{ 1, false };
    CONSOLE_SCREEN_BUFFER_INFO ConsoleScreenBufferInfo{ 0, };
    GetConsoleScreenBufferInfo(ConsoleHandle, &ConsoleScreenBufferInfo);
    Console.Rect.first = ConsoleScreenBufferInfo.dwSize.X;
    Console.Rect.second = ConsoleScreenBufferInfo.dwSize.Y;

    //GENERIC_READ
    Console.HBuffer[0] = CreateConsoleScreenBuffer(GENERIC_READ | GENERIC_WRITE, 0, NULL, CONSOLE_TEXTMODE_BUFFER, NULL);
    SetConsoleScreenBufferSize(Console.HBuffer[0], ConsoleScreenBufferInfo.dwSize);
    SetConsoleWindowInfo(Console.HBuffer[0], TRUE, &ConsoleScreenBufferInfo.srWindow);
    SetConsoleCursorInfo(Console.HBuffer[0], &ConsoleCursorInfo);

    Console.HBuffer[1] = CreateConsoleScreenBuffer(GENERIC_READ | GENERIC_WRITE, 0, NULL, CONSOLE_TEXTMODE_BUFFER, NULL);
    SetConsoleScreenBufferSize(Console.HBuffer[1], ConsoleScreenBufferInfo.dwSize);
    SetConsoleWindowInfo(Console.HBuffer[1], TRUE, &ConsoleScreenBufferInfo.srWindow);
    SetConsoleCursorInfo(Console.HBuffer[1], &ConsoleCursorInfo);
}

void FConsoleLayoutContainer::ClearScreen()
{
    COORD pos{ 0, 0};
    DWORD dwWritten = 0;
    unsigned size = Console.Rect.second * Console.Rect.first;

    // 콘솔 화면 전체를 띄어쓰기를 넣어 빈 화면처럼 만듭니다.
    //FillConsoleOutputCharacter(Console.HConsole, '*', size, pos, &dwWritten);
    //SetConsoleCursorPosition(Console.HConsole, pos);

    FillConsoleOutputCharacter(Console.HBuffer[Console.CurBufferIndex], ' ', size, pos, &dwWritten);
    SetConsoleCursorPosition(Console.HBuffer[Console.CurBufferIndex], pos);
}

void FConsoleLayoutContainer::SwapBuffer()
{
    SetConsoleActiveScreenBuffer(Console.HBuffer[Console.CurBufferIndex]);
    Console.CurBufferIndex = Console.CurBufferIndex ? 0 : 1;
}